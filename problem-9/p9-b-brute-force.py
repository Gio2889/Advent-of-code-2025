import sys
from pathlib import Path
from typing import List,Tuple,AnyStr
from math import floor
import numpy  as np
import time
sys.path.append(str(Path(__file__).parent.parent))

from utils.txt_to_list_reader import txt_to_list_reader

def get_area(red_tiles):
    n = len(red_tiles)
    grid_high_x = 0
    grid_high_y = 0
    print("Transforming to strings...")
    # transform to ints 
    for i in range(n):
        tile  = red_tiles[i]
        split_str = tile.split(",")
        x = int(split_str[0])
        y = int(split_str[1])
        red_tiles[i] = (x,y)
    ####################
        if x> grid_high_x:
            grid_high_x = x
        if y > grid_high_y:
            grid_high_y = y
    print("Making map and painting it...")
    tile_map = np.array([["." for _ in range(grid_high_x+2)] for _ in range(grid_high_y+2)])
    boundary = set()
    for i in range(n):
        x1,y1 = red_tiles[i]
        x2,y2 = red_tiles[(i+1)%n]
        boundary.add((x1,y1))
        boundary.add((x2,y2))
        tile_map[y1,x1] = '#'
        tile_map[y2,x2] = '#'
        if x1 == x2:  # Vertical line
            start_y, end_y = min(y1, y2), max(y1, y2)
            for y in range(start_y + 1, end_y):
                tile_map[y][x1] = '0'
                boundary.add((x1,y))
        elif y1 == y2:  # Horizontal line
            start_x, end_x = min(x1, x2), max(x1, x2)
            for x in range(start_x + 1, end_x):
                tile_map[y1][x] = '0'
                boundary.add((x,y1))
    print("Boundaries set...")
    print("Floding...")
    #flood inside
    for x in range(grid_high_x+2):
        for y in range(grid_high_y+2):
            if (x,y) in boundary:
                continue
            intersections = 0 #must be inside odd to be inside
            # this s simple ray cating algo to determine your inside or not
            # casting a ray from the point to the right it must only cross odd number boundaries to be inside
            # in this case it only crosses once I think, the shape does not have holes
            for i in range(n): 
                x1, y1 = red_tiles[i]
                x2, y2 = red_tiles[(i + 1) % n]
                
                if (y1 <= y < y2) or (y2 <= y < y1): 
                    if x1 == x2:
                        if x1 > x:
                            intersections += 1
                    # else: # we dont need the intercept becuase of rectilinear 
                    #     intersect_x = (x2 - x1) * (y - y1) / (y2 - y1) + x1
                    #     if intersect_x > x:
                    #         intersections += 1
            if intersections % 2 == 1:
                tile_map[y, x] = 'X'
    print("map is done!")
    #print(tile_map.shape)
    # print(tile_map)
    # exit()
    print("Checking area...")
    largest_area = 0
    generating_pair = ()
    
    for i in range(n):
        for j in range(i+1,n):
            if i!=j:
                x1 = red_tiles[i][0]
                y1 = red_tiles[i][1]
                x2 = red_tiles[j][0]
                y2 = red_tiles[j][1]
                dx = abs(x1-x2)+1 
                dy = abs(y1-y2)+1
                #calculate and check the four corner
                corner1 = (x1,y1) #true points
                corner2 = (x2,y2) #true points
                corner3 = (x1,y2)
                corner4 = (x2,y1)
                for corner in [corner3,corner4]:
                    x,y = corner
                    if tile_map[y,x] == ".": #a corner is out of bounds not a valid square
                        area =0
                        break
                    else:
                        area = dx*dy
                if area > largest_area:
                    largest_area =  area
                    generating_pair = (red_tiles[i],red_tiles[j])

    print(f"Larges area: {largest_area}")
    print(f"Generated by: {generating_pair}")



if __name__ == "__main__":
    red_tiles =  txt_to_list_reader("problem-9/real-input.txt")
    get_area(red_tiles)